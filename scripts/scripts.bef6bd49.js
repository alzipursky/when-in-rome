"use strict";angular.module("romanNumeralsWebsiteFrontendApp",["ngAnimate","ngCookies","ngResource","ngRoute","ngSanitize","ngTouch"]).config(["$routeProvider","$locationProvider",function(a,b){b.hashPrefix(""),a.when("/",{templateUrl:"views/main.html",controller:"MainCtrl",controllerAs:"main"}).when("/input",{templateUrl:"views/data_and_input.html",controller:"AboutCtrl",controllerAs:"about"}).when("/implementation",{templateUrl:"views/implementation.html",controller:"AboutCtrl",controllerAs:"about"}).when("/observations",{templateUrl:"views/observations.html",controller:"AboutCtrl",controllerAs:"about"}).when("/future",{templateUrl:"views/future.html",controller:"AboutCtrl",controllerAs:"about"}).otherwise({redirectTo:"/"})}]),angular.module("romanNumeralsWebsiteFrontendApp").controller("MainCtrl",function(){this.awesomeThings=["HTML5 Boilerplate","AngularJS","Karma"]}),angular.module("romanNumeralsWebsiteFrontendApp").controller("AboutCtrl",function(){this.awesomeThings=["HTML5 Boilerplate","AngularJS","Karma"]}),angular.module("romanNumeralsWebsiteFrontendApp").run(["$templateCache",function(a){a.put("views/about.html","<p>This is the about view.</p>"),a.put("views/data_and_input.html",'<div> <h1 style="text-align: center">Data Set and Existing Code</h1> <h2>Data Set</h2> <p style="font-size: 20px">The data set our system will be using is the kcorpus data set, a series of 47 MIDI files that are excerpts from “Tonal Harmony” by Stefan Kostka and Dorothy Payne. From Beethoven and Bach to Brahms and Tchaikovsky, these excerpts will have more than enough variety in harmony. Most importantly, these files are already pre-labeled with the chord names, saving us many hours of tedious harmonic analysis. This data set is uniquely tailored to our project in that the excerpts vary in rhythm, tonal area (keys), and even modulate keys.</p> <h2>Melisma Music Analyzer</h2> <p style="font-size: 20px">To handle the chord finding in our system, we took advantage of an existing system called the <strong>Melisma Music Analyzer</strong>, built by David Temperly (<a href="http://www.link.cs.cmu.edu/music-analysis/">link</a>). This program takes a midi file as input, and will return each segment of the piece labeled with what notes were played in that segment and the system’s guess for what chord was played during that segment. More specifically, we used Temperley\'s <strong>mftext program</strong> to convert a midifile to list of notes, his <strong>Meter program</strong> (<a href="http://www.link.cs.cmu.edu/music-analysis/meter.html">link</a>) to generate a list of beats from that note list, and his <strong>Harmony program</strong> (<a href="http://www.link.cs.cmu.edu/music-analysis/harmony.html">link</a>) to break the piece into chord segments and guess the chord label based on the notes in that segment.<br><br> One drawback to Temperly’s system is it does not include musical modes with the chord labels, which are necessary for determining Roman Numerals and key. We accounted for this later by building functionality that will guess the musical model of a chord based on the Temperly\'s guess for the chord label and the notes present during the chord segment.</p> </div>'),a.put("views/future.html",'<div> <h1 style="text-align: center">Future Works</h1> <h2>Improvements</h2> <p style="font-size: 20px">The algorithm had 19 chords, which were certainly identifiable by hand, but the Roman Numerals were obscured. For chords whose root was not diatonic to the key, or unidentifiable by a secondary dominant, we omitted a roman numeral label. Therefore, in the future the algorithm needs a bigger dataset so that every chord that can be labeled by hand, can be labeled by the algorithm.</p> </div>'),a.put("views/implementation.html",'<div> <h1 style="text-align: center">Implementation</h1> <div> <h2>Step 1</h2> <p style="font-size: 20px">Convert output of Melisma Music Analyzer to a list of ordered tuples.</p> <ul> <li style="font-size: 16px">For each segment, generate a tuple consisting of chord name and a list of notes in the chord. </li> </ul> <p style="font-size: 20px">Ex: [C, (C,D,E,F,G,E,C)], [F, (C,D,E,F,G,A,F)], [G, (D,D,G,A,B,C,D)], [C, (C,D,E,F,G,E,C)]</p> </div> <div> <h2>Step 2</h2> <p style="font-size: 20px">Label the quality of each chord</p> <ul> <li style="font-size: 16px">To determine the quality of the chords, we used the root of the chord and the intervallic relationship of each note of the segment (in chroma) from the root. </li> <li style="font-size: 16px">After identifying which series of intervals the segment contained, we append the quality to the root </li> </ul> <p style="font-size: 20px">Ex: </p> <ul> <li style="font-size: 16px"><strong>Input</strong>: [C, (C,D,E,F,G,E,C)], [F, (C,D,E,F,G,A,F)], [G, (D,D,G,A,B,C,D)], [C, (C,D,E,F,G,E,C)] </li> <li style="font-size: 16px"><strong>Output</strong> (given the following table): [CMaj,FMaj,GMaj,CMaj] </li></ul> <!--<img src="images/interval_relationships.b74de0c4.png" style="width:300px;height:300px;border:0;">--> <img src="images/interval_relationships.b74de0c4.png" style="width:30%;height:30%;border:0"> </div> <div> <h2>Step 3</h2> <p style="font-size: 20px">Convert labels to Roman Numerals in a certain key</p> <ul> <li style="font-size: 16px">For each chord (labeled with it\'s quality), find a vector containing the solfege (in chroma) that correspond to the notes in that chord. To do this, we\'ve manually compiled a dictionary of common chords and their corresponding solfege vectors. </li> <li style="font-size: 16px">The solfege we generate is in C Major, so it must converted to the key we\'re currently analyzing the piece in. To do this, we find the chroma of the key we\'re currently analyzing in, and subtract that value from each solfege value (+ 12 % 12 to account for negative numbers). </li> <li style="font-size: 16px">Detect the inversion of the chord. We do this by computing the difference (in chroma) of the lowest pitch in the chord, and the root of the chord (both the root and pitch of the lowest note are returned from Temperley\'s system). Once the inversion is known for each chord, shuffle the solfege in the chord based upon the inversion. </li> <li style="font-size: 16px">Finally, for each transposed solfege vector, find that the corresponding Roman Numeral label. To do this, we\'ve manually compiled a dictionary of common solfege vectors and their corresponding Roman Numeral labels. Due to the fact that we\'ll be analyzing pieces in the wrong key (in order to determine the correct key), it\'s possible that solfege vectors will be created that don\'t map to any Roman Numerals. </li> </ul> <p style="font-size: 20px">Ex: </p> <ul> <li style="font-size: 16px"><strong>Input</strong>: [Dmaj, GMaj, Emin7, Dmaj, Amaj, Dmaj] analyzed in D</li> <li style="font-size: 16px"><strong>Becomes</strong>: [(2,6,9), (7,11,2), (11,2,4,7), (2,6,9), (9,1,4), (2,6,9)]</li> <li style="font-size: 16px"><strong>Becomes</strong>: [(0,4,7), (5,9,0), (9,0,2,5), (0,4,7), (7,11,2), (0,4,7)]</li> <li style="font-size: 16px"><strong>Becomes</strong>: [(0,4,7), (5,9,0), (2,5,9,0), (0,4,7), (7,11,2), (0,4,7)]</li> <li style="font-size: 16px"><strong>Output</strong>: [I, IV, ii65, I, V, I]</li> </ul> </div> <div> <h2>Step 4</h2> <p style="font-size: 20px">Compute a score for how likely a key is correct based on the Roman Numerals present</p> <ul> <li style="font-size: 16px">For each possible key, give points to that key based on the presence of certain Roman Numerals</li> <li style="font-size: 16px">Each I (i), IV (iv), V (v), ii, and vi chord present gets one point.</li> <li style="font-size: 16px">The presence of a V (v) to I (i) cadence is the best characteristic of a correct key, so each cadence gets 5 points.</li> <li style="font-size: 16px">The number of major/minor tonics present tells us whether or not the key is major or minor</li> <li style="font-size: 16px">Finally, find the max score out of all the keys, and the corresponding key is the key of the piece</li> </ul> <p style="font-size: 20px">Example output </p> <!--<img src="images/sample_output.105498c7.png" style="width:800px;height:80px;border:0;">--> <img src="images/sample_output.105498c7.png" style="width:80%;height:80%;border:0"> </div> </div>'),a.put("views/main.html",'<div> <h1 style="text-align: center">Introduction</h1> <h2>Overview</h2> <p style="font-size: 20px">Our goal was to automate the chordal analysis process: using existing code that takes MIDI input and labels chords (e.g., C Major), the additional step that our code is adding is the roman numeral notation. While we are not solving a “problem” per say, as harmonic analysis is always subjective to some degree, we would be contributing to the discipline of automating music theory and conducting an experiment as to whether such analyses are even possible, and most importantly, sufficiently accurate.</p> <h2>Motivation</h2> <p style="font-size: 20px">As a group composed of music aficionados and music majors, we know that harmonies play a major role in why certain pieces sound “cool,” or evocative of a certain style or feel. Furthermore, chordal analysis is one of the fundamental tools to Western Tonal Music analysis. While chord labeling is fascinating in itself, understanding and hearing harmonies functionally is what really allows one to understand the “how” and “why” in music.</p> </div>'),a.put("views/observations.html",'<div> <h1 style="text-align: center">Observations</h1> <h2>Accuracy</h2> <p style="font-size: 20px">Across the 47 MIDI excerpt examples provided in our data set, of the 908 total chords, only 19 chords did not have a corresponding Roman Numeral. In other words, our algorithm performed with a 97.9% accuracy rate (889/908 Identifiable Roman Numerals). </p> <h2>Roman Numeral Accuracy/Strength Is Only as Robust as the Data Set</h2> <p style="font-size: 20px">Beyond kcorpus, our dataset of our MIDI excerpts, the most important dataset we constructed was solfege_to_roman_numerals.csv, 208 key value pairs, where the key is a vector of 4 solfeggi and the value is a roman numeral represented as a string (e.g., I6). Starting only with diatonic chords, or rather chords built from solfege consistent of only the major/minor mode, our performance was very weak, output 211 ‘None’ chords and an overall performance of 76.76% accuracy. By adding secondary dominant chords, extended dominants, neapolitan, and augmented 6th chords, and other non-diatonic chromatic chords (which are often found in Western Tonal Music), our accuracy improved by 21.14% percent, as our algorithm was able to correctly identify 192 previously unknown roman numerals.<br></p> <p style="font-size: 20px">For the other 19 chords, while they were certainly identifiable by hand, the Roman Numerals were beginning to be obscured. For chords whose root was not diatonic to the key, or unidentifiable by a secondary dominant, we omitted a roman numeral label. For an example, in the key of C Major, if we had an F#aug7, we could could call it bvo7 or or IV+o7, neither of which are typical roman numerals one would encounter.</p> <h2>Implied Harmony is the Most Complex Part of Our Algorithm</h2> <p style="font-size: 20px">In these MIDI excerpts, often times all the corresponding pitches to a particular harmony were not present. As a result, for a given segment, our algorithm had to identify the “implied harmony,” or rather the likely intended harmony for a certain series of notes. However, implied harmony is an art, not a science. Consider the following example: </p> <img src="images/observations_example_1.7971e2be.png" style="width:50%;height:50%;border:0"> <p style="font-size: 20px"> In the first beat, we have a C Major triad with all 3 pitches (C,E,G), and the second beat we have a C Minor triad with all 3 pitches (C,Eb,G). However, in the 3rd beat, we are missing the middle note. However, in this chord, did the composer intend to write an E or Eb? Questions like these are where implied harmony takes over. In this case, we can’t know; but if we don’t provide an answer to our algorithm, our output will result in ‘None.’ Thus, the heart of any inaccuracies of algorithm lies with the implied harmony. If we correctly identify the root and quality of a chord, after finding the inversion, our roman numeral will always be correct. However, if we incorrectly identify the quality from the implied harmony, our Roman Numeral analysis would suffer. Some examples of where our implied harmony could have failed would be the following: </p> <p style="font-size: 20px"><strong>Passing Tones/Neighbor Tones</strong></p> <img src="images/observations_example_2.409d12b2.png" style="width:60%;height:60%;border:0"> <p style="font-size: 20px">In this example, the 1st beat clearly features a C chord; but is it major or minor? We have on the second 8th note a D# followed by an E. To our algorithm, it notices a major 3rd, the integral component of the major triad (e.g., C Major), and a minor 3rd, the integral component of the minor triad (e.g., C minor). Currently, our algorithm has no way to identify the common interpretation of this case; the D# should be seen as a “passing tone” to the E, and thus we can exclude the D# or Eb in our triad built on C. Instead, our algorithm may arbitrarily choose between major and minor in this case.</p> <p style="font-size: 20px"><strong>Tonic Resolution with No 3rd/5th</strong></p> <!--<img src="images/observations_example_3.9e7cfc89.png" style="width:800px;height:250px;border:0;">--> <img src="images/observations_example_3.9e7cfc89.png" style="width:60%;height:60%;border:0"> <p style="font-size: 20px">In this case, the first two beats clearly outline a G Major triad, serving as a dominant functioning chord (V) to what appears to be C Major. But upon closer inspection, the 3rd beat only features two Cs without any other identifying features of the quality. In this case, the implied harmony could be C minor if the excerpt had already featured other instances of c minor; however, our current implied algorithm doesn’t have access to prior chords, and would thus default to labeling as a major triad in cases that the root pitch is present.</p> <h2>Vague vs. Ambiguous</h2> <p style="font-size: 20px">Across the discipline of music theory, harmonic analysis can be seen as incredibly challenging and complex. However, chordal analysis must not be seen as “vague” but rather ambidextrous – taking on a variety of interpretations contingent on particular assumptions. While our project displayed tremendous accuracy in terms of identifying the exact chord present, the roman numeral ultimately hinged on the identified implied harmony. A more robust and comprehensive implied harmony algorithm would result in a more accurate display of the harmonic properties of an excerpt.</p> <h2>Harmonic Analysis Can be Used as a Tool for Composition: </h2> <p style="font-size: 20px">The great Spanish guitarist Fernando Sor (1778-1839) often said that he would write out the harmonies before composing the melodies and expanding the compositions to their final forms. Such technique, first writing out a harmonic ‘skeleton’ of the piece’ before the composition itself, is often taught today across music theory curricula. Thus, one could use our algorithm to confirm the harmonies of a compositional ‘skeleton’ before the completion of a piece.</p> <h2>The Accuracy of Our Algorithm is Entirely Contingent on Accuracy of Temperley’s Melisma Music Analyzer</h2> <p style="font-size: 20px">For our algorithm to correctly label the roman numerals, the key assumption we are making is that David Temperley’s Melisma algorithm correctly labels the root of the chord. However, in cases that he fails to identify the correct root pitch, the particular roman numeral accuracy fails. Consider this example:</p> <img src="images/observations_example_4.2dff36fd.png" style="width:70%;height:70%;border:0"> <p style="font-size: 20px">This current progression timeline is I vii07 IV6 V7 I, and the correct root motion is C B A G C. However, Temperley’s output incorrectly identifies the root of the second chord as G, leading to an incorrect Roman Numeral analysis (V65). While a V65 and vii07 are both dominant-function chords with ‘ti’ as the bass, the aural perception of these two chords is quite different. This example illustrates a shortcoming of Temperley’s algorithm and by extension, our algorithm as well.</p> </div>')}]);